// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: blobs.sql

package sqldb

import (
	"context"
	"strings"
	"time"
)

const claimChatBlobsForMessage = `-- name: ClaimChatBlobsForMessage :execrows
UPDATE blobs
SET message_id = ?1,
    claimed_at = ?2,
    expires_at = NULL
WHERE kind = 'chat_attachment'
  AND uploaded_by = ?3
  AND message_id IS NULL
  AND (expires_at IS NULL OR expires_at > ?4)
  AND id IN (/*SLICE:blob_ids*/?)
`

type ClaimChatBlobsForMessageParams struct {
	MessageID  *string
	ClaimedAt  *time.Time
	UploadedBy string
	Now        *time.Time
	BlobIds    []string
}

func (q *Queries) ClaimChatBlobsForMessage(ctx context.Context, arg ClaimChatBlobsForMessageParams) (int64, error) {
	query := claimChatBlobsForMessage
	var queryParams []interface{}
	queryParams = append(queryParams, arg.MessageID)
	queryParams = append(queryParams, arg.ClaimedAt)
	queryParams = append(queryParams, arg.UploadedBy)
	queryParams = append(queryParams, arg.Now)
	if len(arg.BlobIds) > 0 {
		for _, v := range arg.BlobIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:blob_ids*/?", strings.Repeat(",?", len(arg.BlobIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:blob_ids*/?", "NULL", 1)
	}
	result, err := q.db.ExecContext(ctx, query, queryParams...)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createBlob = `-- name: CreateBlob :exec
INSERT INTO blobs (
    id,
    kind,
    uploaded_by,
    storage_path,
    mime_type,
    size_bytes,
    original_name,
    expires_at,
    created_at
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4,
    ?5,
    ?6,
    ?7,
    ?8,
    ?9
)
`

type CreateBlobParams struct {
	ID           string
	Kind         string
	UploadedBy   string
	StoragePath  string
	MimeType     string
	SizeBytes    int64
	OriginalName string
	ExpiresAt    *time.Time
	CreatedAt    time.Time
}

func (q *Queries) CreateBlob(ctx context.Context, arg CreateBlobParams) error {
	_, err := q.db.ExecContext(ctx, createBlob,
		arg.ID,
		arg.Kind,
		arg.UploadedBy,
		arg.StoragePath,
		arg.MimeType,
		arg.SizeBytes,
		arg.OriginalName,
		arg.ExpiresAt,
		arg.CreatedAt,
	)
	return err
}

const deleteBlobByID = `-- name: DeleteBlobByID :execrows
DELETE FROM blobs
WHERE id = ?1
`

func (q *Queries) DeleteBlobByID(ctx context.Context, id string) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteBlobByID, id)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getBlobByID = `-- name: GetBlobByID :one
SELECT id, kind, uploaded_by, storage_path, mime_type, size_bytes, original_name, message_id, claimed_at, expires_at, created_at,
       preview_storage_path, preview_mime_type, preview_size_bytes, preview_width, preview_height
FROM blobs
WHERE id = ?1
LIMIT 1
`

type GetBlobByIDRow struct {
	ID                 string
	Kind               string
	UploadedBy         string
	StoragePath        string
	MimeType           string
	SizeBytes          int64
	OriginalName       string
	MessageID          *string
	ClaimedAt          *time.Time
	ExpiresAt          *time.Time
	CreatedAt          time.Time
	PreviewStoragePath *string
	PreviewMimeType    *string
	PreviewSizeBytes   *int64
	PreviewWidth       *int64
	PreviewHeight      *int64
}

func (q *Queries) GetBlobByID(ctx context.Context, id string) (GetBlobByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getBlobByID, id)
	var i GetBlobByIDRow
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.UploadedBy,
		&i.StoragePath,
		&i.MimeType,
		&i.SizeBytes,
		&i.OriginalName,
		&i.MessageID,
		&i.ClaimedAt,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.PreviewStoragePath,
		&i.PreviewMimeType,
		&i.PreviewSizeBytes,
		&i.PreviewWidth,
		&i.PreviewHeight,
	)
	return i, err
}

const listExpiredUnclaimedChatBlobs = `-- name: ListExpiredUnclaimedChatBlobs :many
SELECT id, storage_path, preview_storage_path
FROM blobs
WHERE kind = 'chat_attachment'
  AND message_id IS NULL
  AND expires_at IS NOT NULL
  AND expires_at <= ?1
ORDER BY expires_at ASC
LIMIT ?2
`

type ListExpiredUnclaimedChatBlobsParams struct {
	Now       *time.Time
	LimitRows int64
}

type ListExpiredUnclaimedChatBlobsRow struct {
	ID                 string
	StoragePath        string
	PreviewStoragePath *string
}

func (q *Queries) ListExpiredUnclaimedChatBlobs(ctx context.Context, arg ListExpiredUnclaimedChatBlobsParams) ([]ListExpiredUnclaimedChatBlobsRow, error) {
	rows, err := q.db.QueryContext(ctx, listExpiredUnclaimedChatBlobs, arg.Now, arg.LimitRows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListExpiredUnclaimedChatBlobsRow{}
	for rows.Next() {
		var i ListExpiredUnclaimedChatBlobsRow
		if err := rows.Scan(&i.ID, &i.StoragePath, &i.PreviewStoragePath); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessageAttachments = `-- name: ListMessageAttachments :many
SELECT id, original_name, mime_type, size_bytes, created_at,
       preview_storage_path, preview_mime_type, preview_size_bytes, preview_width, preview_height
FROM blobs
WHERE message_id = ?1
  AND kind = 'chat_attachment'
ORDER BY created_at ASC, id ASC
`

type ListMessageAttachmentsRow struct {
	ID                 string
	OriginalName       string
	MimeType           string
	SizeBytes          int64
	CreatedAt          time.Time
	PreviewStoragePath *string
	PreviewMimeType    *string
	PreviewSizeBytes   *int64
	PreviewWidth       *int64
	PreviewHeight      *int64
}

func (q *Queries) ListMessageAttachments(ctx context.Context, messageID *string) ([]ListMessageAttachmentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listMessageAttachments, messageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMessageAttachmentsRow{}
	for rows.Next() {
		var i ListMessageAttachmentsRow
		if err := rows.Scan(
			&i.ID,
			&i.OriginalName,
			&i.MimeType,
			&i.SizeBytes,
			&i.CreatedAt,
			&i.PreviewStoragePath,
			&i.PreviewMimeType,
			&i.PreviewSizeBytes,
			&i.PreviewWidth,
			&i.PreviewHeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessageAttachmentsByMessageIDs = `-- name: ListMessageAttachmentsByMessageIDs :many
SELECT message_id, id, original_name, mime_type, size_bytes, created_at,
       preview_storage_path, preview_mime_type, preview_size_bytes, preview_width, preview_height
FROM blobs
WHERE kind = 'chat_attachment'
  AND message_id IN (/*SLICE:message_ids*/?)
ORDER BY message_id ASC, created_at ASC, id ASC
`

type ListMessageAttachmentsByMessageIDsRow struct {
	MessageID          *string
	ID                 string
	OriginalName       string
	MimeType           string
	SizeBytes          int64
	CreatedAt          time.Time
	PreviewStoragePath *string
	PreviewMimeType    *string
	PreviewSizeBytes   *int64
	PreviewWidth       *int64
	PreviewHeight      *int64
}

func (q *Queries) ListMessageAttachmentsByMessageIDs(ctx context.Context, messageIds []*string) ([]ListMessageAttachmentsByMessageIDsRow, error) {
	query := listMessageAttachmentsByMessageIDs
	var queryParams []interface{}
	if len(messageIds) > 0 {
		for _, v := range messageIds {
			queryParams = append(queryParams, v)
		}
		query = strings.Replace(query, "/*SLICE:message_ids*/?", strings.Repeat(",?", len(messageIds))[1:], 1)
	} else {
		query = strings.Replace(query, "/*SLICE:message_ids*/?", "NULL", 1)
	}
	rows, err := q.db.QueryContext(ctx, query, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMessageAttachmentsByMessageIDsRow{}
	for rows.Next() {
		var i ListMessageAttachmentsByMessageIDsRow
		if err := rows.Scan(
			&i.MessageID,
			&i.ID,
			&i.OriginalName,
			&i.MimeType,
			&i.SizeBytes,
			&i.CreatedAt,
			&i.PreviewStoragePath,
			&i.PreviewMimeType,
			&i.PreviewSizeBytes,
			&i.PreviewWidth,
			&i.PreviewHeight,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateBlobPreview = `-- name: UpdateBlobPreview :execrows
UPDATE blobs
SET preview_storage_path = ?1,
    preview_mime_type = ?2,
    preview_size_bytes = ?3,
    preview_width = ?4,
    preview_height = ?5
WHERE id = ?6
`

type UpdateBlobPreviewParams struct {
	PreviewStoragePath *string
	PreviewMimeType    *string
	PreviewSizeBytes   *int64
	PreviewWidth       *int64
	PreviewHeight      *int64
	ID                 string
}

func (q *Queries) UpdateBlobPreview(ctx context.Context, arg UpdateBlobPreviewParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateBlobPreview,
		arg.PreviewStoragePath,
		arg.PreviewMimeType,
		arg.PreviewSizeBytes,
		arg.PreviewWidth,
		arg.PreviewHeight,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
