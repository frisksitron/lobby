// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: messages.sql

package sqldb

import (
	"context"
	"time"
)

const createMessage = `-- name: CreateMessage :exec
INSERT INTO messages (
    id,
    author_id,
    content,
    created_at
) VALUES (
    ?1,
    ?2,
    ?3,
    ?4
)
`

type CreateMessageParams struct {
	ID        string
	AuthorID  string
	Content   string
	CreatedAt time.Time
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) error {
	_, err := q.db.ExecContext(ctx, createMessage,
		arg.ID,
		arg.AuthorID,
		arg.Content,
		arg.CreatedAt,
	)
	return err
}

const getMessageByID = `-- name: GetMessageByID :one
SELECT id, author_id, content, created_at, edited_at
FROM messages
WHERE id = ?1
LIMIT 1
`

func (q *Queries) GetMessageByID(ctx context.Context, id string) (Message, error) {
	row := q.db.QueryRowContext(ctx, getMessageByID, id)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.AuthorID,
		&i.Content,
		&i.CreatedAt,
		&i.EditedAt,
	)
	return i, err
}

const listMessageHistory = `-- name: ListMessageHistory :many
SELECT
    m.id,
    m.author_id,
    COALESCE(u.username, '') AS author_name,
    u.avatar_url AS author_avatar_url,
    m.content,
    m.created_at,
    m.edited_at
FROM messages m
LEFT JOIN users u ON m.author_id = u.id
ORDER BY m.rowid DESC
LIMIT ?1
`

type ListMessageHistoryRow struct {
	ID              string
	AuthorID        string
	AuthorName      string
	AuthorAvatarUrl *string
	Content         string
	CreatedAt       time.Time
	EditedAt        *time.Time
}

func (q *Queries) ListMessageHistory(ctx context.Context, limitRows int64) ([]ListMessageHistoryRow, error) {
	rows, err := q.db.QueryContext(ctx, listMessageHistory, limitRows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMessageHistoryRow{}
	for rows.Next() {
		var i ListMessageHistoryRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.AuthorName,
			&i.AuthorAvatarUrl,
			&i.Content,
			&i.CreatedAt,
			&i.EditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMessageHistoryBefore = `-- name: ListMessageHistoryBefore :many
SELECT
    m.id,
    m.author_id,
    COALESCE(u.username, '') AS author_name,
    u.avatar_url AS author_avatar_url,
    m.content,
    m.created_at,
    m.edited_at
FROM messages m
LEFT JOIN users u ON m.author_id = u.id
WHERE m.rowid < (SELECT rowid FROM messages WHERE messages.id = ?1)
ORDER BY m.rowid DESC
LIMIT ?2
`

type ListMessageHistoryBeforeParams struct {
	BeforeID  string
	LimitRows int64
}

type ListMessageHistoryBeforeRow struct {
	ID              string
	AuthorID        string
	AuthorName      string
	AuthorAvatarUrl *string
	Content         string
	CreatedAt       time.Time
	EditedAt        *time.Time
}

func (q *Queries) ListMessageHistoryBefore(ctx context.Context, arg ListMessageHistoryBeforeParams) ([]ListMessageHistoryBeforeRow, error) {
	rows, err := q.db.QueryContext(ctx, listMessageHistoryBefore, arg.BeforeID, arg.LimitRows)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListMessageHistoryBeforeRow{}
	for rows.Next() {
		var i ListMessageHistoryBeforeRow
		if err := rows.Scan(
			&i.ID,
			&i.AuthorID,
			&i.AuthorName,
			&i.AuthorAvatarUrl,
			&i.Content,
			&i.CreatedAt,
			&i.EditedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
